//일단 dp로 해결하는건 맞음
//근데 초기값 규칙이 없는 것 같음
// 이전에 알던 dp들은 초기값이 명확히 있고 그걸 바탕으로 점점 최적해를 구해갔는데 이번건 아닌듯

// N = 5일때
// 1개
// 5

// 2개
// 55, 5+5, 5-5, 5/5, 5*5

// 3개
// 555
// 5+55, 5-55, 555, 5/55
// 5+(5+5), 5-(5+5), 5(5+5), 5/(5+5)
// 5+(5-5), 5-(5-5), 5(5-5), 5/(5-5)
// 5+(5/5), 5-(5/5), 5(5/5), 5/(5/5)
// 5+(55), 5-(55), 5(55), 5(55)
// 55+5, 55-5, 555, 55/5
// (5+5)+5, (5+5)-5, (5+5)5, (5+5)/5
// (5-5)+5, (5-5)-5, (5-5)5, (5-5)/5
// (5/5)+5, (5/5)-5, (5/5)5, (5/5)/5
// (55)+5, (55)-5, (55)5, (5*5)/5

function solution(N, number) {
    if (N==number) return 1
   const dp = Array.from({ length: 9 }, () => new Set()); 
    
      dp[1].add(N);
    
    
     for (let i = 2; i <= 8; i++) {
      
        dp[i].add(Number(String(N).repeat(i)));

   
        for (let j = 1; j < i; j++) {
            for (const a of dp[j]) {
                for (const b of dp[i - j]) {
                   
                    dp[i].add(a + b);
                    dp[i].add(a - b);
                    dp[i].add(a * b);
                    if (b !== 0) dp[i].add(Math.floor(a / b)); 
                }
            }
        }
       
  
        if (dp[i].has(number)) return i;
    }

    return -1; 
}
